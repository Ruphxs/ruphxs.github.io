<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interactive Universe — Viral Edition</title>
  <style>
    :root{
      --bg:#000000;          /* background color */
      --particle:#ffffff;    /* particle color (when not palette/multicolor) */
      --link:#ffffff;        /* line/link color */
      --ui-bg:rgba(0,0,0,.55);
      --ui-bd:rgba(255,255,255,.12);
      --ui-text:#fff;
    }
    html,body{height:100%;margin:0}
    body{background:var(--bg);overflow:hidden;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#fff}
    #canvas{position:fixed;inset:0;display:block;background:var(--bg)}
    .hud{position:fixed;left:12px;top:12px;background:var(--ui-bg);backdrop-filter:blur(8px);border:1px solid var(--ui-bd);border-radius:14px;padding:10px 12px;display:flex;gap:8px;flex-wrap:wrap;align-items:center;max-width:min(92vw,900px)}
    .hud label{font-size:12px;opacity:.9}
    .hud input[type="range"]{width:120px}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 8px;background:#0c0c0c;border:1px solid #2a2a2a;border-radius:10px}
    .btn{cursor:pointer;border:1px solid #2a2a2a;background:#111;color:#fff;border-radius:10px;padding:8px 10px;font-size:12px}
    .btn:hover{background:#161616}
    select{background:#0c0c0c;color:#fff;border:1px solid #2a2a2a;border-radius:8px;padding:6px}
    .stat{position:fixed;right:12px;top:12px;background:var(--ui-bg);border:1px solid var(--ui-bd);border-radius:12px;padding:8px 10px;font-size:12px;min-width:140px}
    .footer{position:fixed;left:12px;bottom:12px;font-size:12px;opacity:.7}
    .toggle{display:inline-flex;align-items:center;gap:6px}
    .toggle input{accent-color:#fff}
    .rec{position:fixed;right:12px;bottom:12px;display:flex;align-items:center;gap:8px;background:var(--ui-bg);border:1px solid var(--ui-bd);border-radius:12px;padding:8px 10px;font-size:12px}
    .rec-dot{width:10px;height:10px;border-radius:999px;background:#e53935;animation:pulse 1s infinite ease-in-out;display:none}
    .rec.live .rec-dot{display:inline-block}
    @keyframes pulse{0%{transform:scale(1);opacity:1}50%{transform:scale(1.4);opacity:.5}100%{transform:scale(1);opacity:1}}
    .safe{position:fixed;inset:0;pointer-events:none}
    .safe.hide{display:none}
    .safe .frame{position:absolute;inset:0;border:2px dashed rgba(255,255,255,.15)}
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="safe hide" id="safe">
    <div class="frame"></div>
  </div>

  <div class="hud" role="toolbar" aria-label="Particle Controls">
    <!-- Modes / Palettes -->
    <span class="chip">
      <label for="mode">Mode</label>
      <select id="mode">
        <option>Starfield</option>
        <option>Vortex</option>
        <option>Flow Field</option>
        <option>Orbits</option>
      </select>
    </span>
    <span class="chip">
      <label for="palette">Palette</label>
      <select id="palette">
        <option value="mono">Monochrome</option>
        <option value="neon">Neon</option>
        <option value="sunset">Sunset</option>
        <option value="ocean">Ocean</option>
        <option value="pepe">Pepe Green</option>
        <option value="random">Randomize</option>
      </select>
    </span>

    <!-- Colors / Counts -->
    <span class="chip">
      <label for="color">Particles</label>
      <input id="color" type="color" value="#ffffff" title="Particle color"/>
    </span>
    <span class="chip">
      <label for="bg">Background</label>
      <input id="bg" type="color" value="#000000" title="Background color"/>
    </span>
    <span class="chip">
      <label for="count">Count</label>
      <input id="count" type="range" min="100" max="2500" step="50" value="900"/>
      <span id="countVal">900</span>
    </span>
    <span class="chip">
      <label for="speed">Speed</label>
      <input id="speed" type="range" min="0.2" max="3" step="0.1" value="1"/>
      <span id="speedVal">1.0x</span>
    </span>

    <!-- Toggles -->
    <span class="chip toggle"><input id="links" type="checkbox" checked/><label for="links">Links</label></span>
    <span class="chip toggle"><input id="trails" type="checkbox"/><label for="trails">Motion Blur</label></span>
    <span class="chip toggle"><input id="glow" type="checkbox" checked/><label for="glow">Glow</label></span>
    <span class="chip toggle"><input id="gravity" type="checkbox" checked/><label for="gravity">Cursor Gravity</label></span>
    <span class="chip toggle"><input id="autopilot" type="checkbox"/><label for="autopilot">Auto Cinematic</label></span>

    <!-- Special actions -->
    <button id="burst" class="btn" title="Spawn a supernova at your cursor">Supernova</button>
    <button id="reset" class="btn" title="Reset particles">Reset</button>
    <button id="mic" class="btn" title="Enable microphone for audio-reactive mode">Enable Mic</button>

    <!-- TikTok / Recording -->
    <span class="chip toggle"><input id="tiktok" type="checkbox"/><label for="tiktok">TikTok 9:16</label></span>
    <button id="record" class="btn" title="Start/stop recording (WebM)">Start Recording</button>
    <a id="download" class="btn" style="display:none" download="universe.webm">Save Video</a>
  </div>

  <div class="stat" aria-live="polite">
    <div>FPS: <strong id="fps">—</strong></div>
    <div>Particles: <strong id="pcount">—</strong></div>
    <div>Mode: <strong id="modeStat">Starfield</strong></div>
    <div>Beat: <strong id="beat">—</strong></div>
  </div>

  <div class="rec" id="rec"><span class="rec-dot"></span><span id="recLabel">Idle</span></div>

  <div class="footer">Drag to attract/repel • Click for bursts • Try <b>Auto Cinematic</b> + <b>Glow</b> + <b>TikTok</b> + <b>Record</b> for viral-ready clips</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // UI elements
  const el = (id)=>document.getElementById(id);
  const modeSel = el('mode');
  const paletteSel = el('palette');
  const colorEl = el('color');
  const bgEl = el('bg');
  const countEl = el('count');
  const speedEl = el('speed');
  const linksEl = el('links');
  const trailsEl = el('trails');
  const glowEl = el('glow');
  const gravityEl = el('gravity');
  const autopilotEl = el('autopilot');
  const burstBtn = el('burst');
  const resetBtn = el('reset');
  const micBtn = el('mic');
  const tiktokEl = el('tiktok');
  const recordBtn = el('record');
  const dlA = el('download');
  const fpsEl = el('fps');
  const pcountEl = el('pcount');
  const modeStat = el('modeStat');
  const beatEl = el('beat');
  const countVal = el('countVal');
  const speedVal = el('speedVal');
  const recBar = el('rec');
  const safe = el('safe');

  // Canvas size / TikTok mode
  let DPR, W, H;
  let tiktokMode = false;
  function resize(){
    DPR = Math.min(devicePixelRatio || 1, 2);
    if(tiktokMode){
      // Force a 9:16 canvas; default to 1080x1920 for clean exports, scale to window
      const targetW = 1080, targetH = 1920;
      W = canvas.width = Math.floor(targetW * DPR);
      H = canvas.height = Math.floor(targetH * DPR);
      canvas.style.width = targetW + 'px';
      canvas.style.height = targetH + 'px';
      // Fit inside viewport with aspect preserved
      const scale = Math.min(innerWidth/targetW, innerHeight/targetH);
      canvas.style.transformOrigin = 'top left';
      canvas.style.transform = `translate(${(innerWidth-targetW*scale)/2}px, ${(innerHeight-targetH*scale)/2}px) scale(${scale})`;
      safe.classList.remove('hide');
    } else {
      W = canvas.width = Math.floor(innerWidth * DPR);
      H = canvas.height = Math.floor(innerHeight * DPR);
      canvas.style.width = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      canvas.style.transform = 'none';
      safe.classList.add('hide');
    }
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(DPR, DPR);
  }
  addEventListener('resize', resize, {passive:true});

  // Config
  const config = {
    particleColor: colorEl.value,
    bgColor: bgEl.value,
    count: +countEl.value,
    baseSpeed: +speedEl.value,
    link: true,
    trails: false,
    glow: true,
    gravity: true,
    mode: 'Starfield',
    maxLinkDist: 140,
    sizeMin: 1,
    sizeMax: 2.5,
    palette: 'mono',
    multiColor: true,
    autopilot: false,
  };

  // Palettes
  const palettes = {
    mono: ['#ffffff'],
    neon: ['#00ffff','#ff00ff','#ffff00','#00ff88','#ff6b6b'],
    sunset: ['#ffd166','#ef476f','#f78c6b','#06d6a0'],
    ocean: ['#a8dadc','#457b9d','#1d3557','#06d6a0'],
    pepe: ['#98fb98','#32cd32','#2e7d32','#b2ff59'],
  };
  function choosePalette(name){
    if(name==='random'){
      const rand = [];
      for(let i=0;i<5;i++) rand.push('#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0'));
      return rand;
    }
    return palettes[name]||palettes.mono;
  }

  // Sim state
  const pointer = { x: innerWidth/2, y: innerHeight/2, down:false };
  window.addEventListener('pointermove', e => {
    const r = canvas.getBoundingClientRect();
    pointer.x = (e.clientX - r.left);
    pointer.y = (e.clientY - r.top);
  }, {passive:true});
  window.addEventListener('pointerdown', ()=> pointer.down = true, {passive:true});
  window.addEventListener('pointerup', ()=> pointer.down = false, {passive:true});

  class Particle{
    constructor(layer=1){ this.layer = layer; this.reset(true); }
    reset(randPos=false){
      const z = this.layer; // parallax (1..3)
      this.x = randPos ? Math.random()*innerWidth : (Math.random()<.5? -10 : innerWidth+10);
      this.y = randPos ? Math.random()*innerHeight : Math.random()*innerHeight;
      const angle = Math.random()*Math.PI*2;
      const speed = (Math.random()*0.6 + 0.2) * config.baseSpeed * (0.5 + z*0.3);
      this.vx = Math.cos(angle)*speed;
      this.vy = Math.sin(angle)*speed;
      this.size = (Math.random()*(config.sizeMax-config.sizeMin)+config.sizeMin) * (0.7 + z*0.2);
      this.hueIndex = Math.random();
    }
    step(dt){
      const z = this.layer;
      // Mode-specific forces
      if(config.mode==='Vortex'){
        const cx = innerWidth/2, cy = innerHeight/2;
        const dx = this.x - cx, dy = this.y - cy;
        const dist = Math.hypot(dx,dy)+0.0001;
        // tangential velocity for swirl
        const tangential = 40/(dist); // weaker far away
        this.vx += (-dy/dist)*tangential*dt;
        this.vy += ( dx/dist)*tangential*dt;
      } else if(config.mode==='Flow Field'){
        const a = noise2D(this.x*0.002, this.y*0.002) * Math.PI*2;
        this.vx += Math.cos(a) * 8 * dt;
        this.vy += Math.sin(a) * 8 * dt;
      } else if(config.mode==='Orbits'){
        const cx = pointer.x, cy = pointer.y; // orbit pointer
        const dx = this.x - cx, dy = this.y - cy;
        const dist = Math.hypot(dx,dy)+0.0001;
        const tangential = 60/(dist);
        this.vx += (-dy/dist)*tangential*dt;
        this.vy += ( dx/dist)*tangential*dt;
      }

      // Cursor gravity (attract / repel when holding)
      if(config.gravity){
        const dx = pointer.x - this.x;
        const dy = pointer.y - this.y;
        const dist2 = dx*dx + dy*dy;
        const dist = Math.sqrt(dist2)+0.0001;
        const force = (pointer.down ? -30 : 30) / dist2; // repel when down
        this.vx += dx * force * dt * (1 + 0.2*z);
        this.vy += dy * force * dt * (1 + 0.2*z);
      }

      // Audio reactive pulse affects velocity slightly
      if(audioLevel>0){
        const bump = (audioLevel*0.6);
        this.vx *= (1 + bump*dt);
        this.vy *= (1 + bump*dt);
      }

      this.x += this.vx * dt * 60;
      this.y += this.vy * dt * 60;

      // Edge wrap
      if(this.x < -20) this.x = innerWidth + 20;
      if(this.x > innerWidth + 20) this.x = -20;
      if(this.y < -20) this.y = innerHeight + 20;
      if(this.y > innerHeight + 20) this.y = -20;
    }
    draw(){
      const col = getParticleColor(this.hueIndex);
      if(config.glow){
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.18;
        ctx.beginPath(); ctx.fillStyle = col; ctx.arc(this.x, this.y, this.size*3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
      }
      ctx.beginPath();
      ctx.fillStyle = col;
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // Ripples for satisfying click shockwaves
  const ripples = [];
  function addRipple(x,y){
    ripples.push({x,y,r:4,a:0.6});
  }
  function drawRipples(dt){
    for(let i=ripples.length-1;i>=0;i--){
      const r=ripples[i];
      r.r += 300*dt; r.a *= (1-1.5*dt);
      if(r.a<0.02){ ripples.splice(i,1); continue; }
      ctx.strokeStyle = `rgba(255,255,255,${r.a})`;
      ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(r.x, r.y, r.r, 0, Math.PI*2); ctx.stroke();
    }
  }

  // Particles: three parallax layers
  let particles = [];
  function makeParticles(n){
    const perLayer = Math.max(10, Math.floor(n/3));
    particles = [];
    for(let z=1; z<=3; z++){
      for(let i=0;i<perLayer;i++) particles.push(new Particle(z));
    }
  }

  // Colors
  let activePalette = choosePalette(config.palette);
  function getParticleColor(iRatio){
    const list = config.multiColor ? activePalette : [config.particleColor];
    const idx = Math.floor(iRatio * list.length) % list.length;
    return list[idx] || list[0];
  }

  // UI bindings
  function updateTheme(){
    document.documentElement.style.setProperty('--bg', config.bgColor);
    document.documentElement.style.setProperty('--particle', config.particleColor);
    document.documentElement.style.setProperty('--link', config.particleColor);
  }

  colorEl.addEventListener('input', e=>{ config.particleColor = e.target.value; updateTheme(); });
  bgEl.addEventListener('input', e=>{ config.bgColor = e.target.value; updateTheme(); });
  countEl.addEventListener('input', e=>{ const v=+e.target.value; countVal.textContent=v; config.count=v; makeParticles(v); pcountEl.textContent=v;});
  speedEl.addEventListener('input', e=>{ const v=+e.target.value; speedVal.textContent=v.toFixed(1)+'x'; config.baseSpeed=v; particles.forEach(p=>{ p.vx*=v; p.vy*=v; });});
  linksEl.addEventListener('change', e=> config.link = e.target.checked);
  trailsEl.addEventListener('change', e=> config.trails = e.target.checked);
  glowEl.addEventListener('change', e=> config.glow = e.target.checked);
  gravityEl.addEventListener('change', e=> config.gravity = e.target.checked);
  autopilotEl.addEventListener('change', e=> config.autopilot = e.target.checked);
  modeSel.addEventListener('change', e=>{ config.mode = e.target.value; modeStat.textContent = config.mode; });
  paletteSel.addEventListener('change', e=>{ config.palette = e.target.value; activePalette = choosePalette(config.palette); });
  burstBtn.addEventListener('click', ()=>{ supernova(); addRipple(pointer.x, pointer.y); cameraShake(6); });
  resetBtn.addEventListener('click', ()=> makeParticles(config.count));
  tiktokEl.addEventListener('change', e=>{ tiktokMode = e.target.checked; resize(); });

  // Mic / audio reactive
  let analyser=null, audioLevel=0, audioTimer=0;
  micBtn.addEventListener('click', async ()=>{
    try{
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      const ctxA = new (window.AudioContext||window.webkitAudioContext)();
      const src = ctxA.createMediaStreamSource(stream);
      analyser = ctxA.createAnalyser(); analyser.fftSize=2048; src.connect(analyser);
      micBtn.textContent='Mic: ON'; micBtn.disabled=true;
    }catch(err){ alert('Microphone permission denied'); }
  });

  function updateAudio(){
    if(!analyser) { beatEl.textContent='—'; return; }
    const arr = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(arr);
    let sum=0; for(let i=0;i<Math.min(80,arr.length);i++) sum+=arr[i];
    const level = sum / (80*255); // 0..1 approx bass
    // smooth
    audioLevel = audioLevel*0.85 + level*0.15;
    beatEl.textContent = (audioLevel*100|0)+'%';
    // occasional auto burst on strong beat
    audioTimer += 1;
    if(audioLevel>0.38 && audioTimer>20){ supernova(); cameraShake(4); audioTimer=0; }
  }

  // Supernova burst
  function supernova(){
    const cx = pointer.x, cy = pointer.y;
    for(let i=0;i<160;i++){
      const p = new Particle(1+ (i%3));
      p.x = cx; p.y = cy;
      const a = Math.random()*Math.PI*2;
      const s = (Math.random()*5 + 2) * config.baseSpeed;
      p.vx = Math.cos(a)*s;
      p.vy = Math.sin(a)*s;
      particles.push(p);
    }
    // gently clamp back towards target
    setTimeout(()=>{ if(particles.length>config.count) particles.splice(0,particles.length-config.count); }, 1000);
  }
  canvas.addEventListener('click', ()=>{ supernova(); addRipple(pointer.x, pointer.y); cameraShake(5); });

  // Camera shake
  let shakeT=0, shakeAmp=0;
  function cameraShake(a=5, t=300){ shakeAmp=a; shakeT = performance.now()+t; }
  function applyShake(){
    if(performance.now()>shakeT) return;
    const dx = (Math.random()-0.5)*shakeAmp;
    const dy = (Math.random()-0.5)*shakeAmp;
    ctx.setTransform(DPR,0,0,DPR,dx,dy);
  }

  // Autopilot cinematic: change palette/mode and trigger bursts
  setInterval(()=>{
    if(!config.autopilot) return;
    const modes=['Starfield','Vortex','Flow Field','Orbits'];
    config.mode = modes[Math.floor(Math.random()*modes.length)];
    modeSel.value = config.mode; modeStat.textContent = config.mode;
    const pals=['neon','sunset','ocean','pepe','random'];
    config.palette = pals[Math.floor(Math.random()*pals.length)];
    paletteSel.value = config.palette; activePalette = choosePalette(config.palette);
    supernova(); addRipple(Math.random()*innerWidth, Math.random()*innerHeight);
  }, 4000);

  // Recording (WebM)
  let recorder=null, chunks=[];
  recordBtn.addEventListener('click', ()=>{
    if(recorder && recorder.state==='recording'){
      recorder.stop(); recordBtn.textContent='Start Recording'; recBar.classList.remove('live'); el('recLabel').textContent='Saving…';
    } else {
      const stream = canvas.captureStream(60);
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm;codecs=vp8';
      recorder = new MediaRecorder(stream, {mimeType:mime, videoBitsPerSecond: 8_000_000});
      chunks=[];
      recorder.ondataavailable = e=>{ if(e.data.size>0) chunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(chunks, {type:'video/webm'});
        const url = URL.createObjectURL(blob);
        dlA.href = url; dlA.style.display='inline-block'; el('recLabel').textContent='Ready'; recBar.classList.remove('live');
      };
      recorder.start(); recordBtn.textContent='Stop Recording'; recBar.classList.add('live'); el('recLabel').textContent='REC 60fps'; dlA.style.display='none';
    }
  });

  // FPS loop
  let last = performance.now();
  let fps = 60; // smoothed

  function frame(now){
    const dt = Math.min(0.05, (now - last)/1000); last = now;
    const instFps = 1/dt; fps = fps*0.9 + instFps*0.1; fpsEl.textContent = Math.round(fps);
    pcountEl.textContent = particles.length;

    // Clear
    if(config.trails){
      ctx.fillStyle = hexToRgba(config.bgColor, 0.08);
      ctx.fillRect(0,0,innerWidth,innerHeight);
    } else {
      ctx.setTransform(DPR,0,0,DPR,0,0);
      ctx.fillStyle = config.bgColor; ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    applyShake();

    // Draw particles
    for(let i=0;i<particles.length;i++){
      const p = particles[i]; p.step(dt); p.draw();
    }

    // Links (skip if too many for perf)
    if(config.link && particles.length <= 1200){
      const maxD = config.maxLinkDist; const maxD2 = maxD*maxD;
      ctx.strokeStyle = hexToRgba('#ffffff', 0.22);
      for(let i=0;i<particles.length;i++){
        const a = particles[i];
        for(let j=i+1;j<particles.length;j++){
          const b = particles[j];
          const dx = a.x - b.x, dy = a.y - b.y; const d2 = dx*dx + dy*dy;
          if(d2 < maxD2){
            const alpha = 1 - (d2 / maxD2);
            ctx.globalAlpha = Math.min(0.6, alpha + audioLevel*0.5);
            ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(b.x, b.y); ctx.stroke();
          }
        }
      }
      ctx.globalAlpha = 1;
    }

    drawRipples(dt);
    updateAudio();
    requestAnimationFrame(frame);
  }

  // Utils
  function hexToRgba(hex, a){
    const h = hex.replace('#','');
    const bigint = parseInt(h.length===3 ? h.split('').map(c=>c+c).join('') : h, 16);
    const r = (bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  // Simplex noise (small, adapted from public domain reference)
  const grad3 = [ [1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1] ];
  const p = []; for(let i=0;i<256;i++) p[i]=Math.floor(Math.random()*256);
  const perm = new Array(512); for(let i=0;i<512;i++) perm[i]=p[i & 255];
  function dot(g, x, y){ return g[0]*x + g[1]*y; }
  function noise2D(xin, yin){
    const F2 = 0.5*(Math.sqrt(3)-1); const G2 = (3-Math.sqrt(3))/6;
    let n0=0, n1=0, n2=0; const s = (xin+yin)*F2; const i = Math.floor(xin+s); const j = Math.floor(yin+s);
    const t = (i+j)*G2; const X0 = i-t, Y0 = j-t; const x0 = xin-X0, y0 = yin-Y0;
    let i1, j1; if(x0>y0){ i1=1; j1=0; } else { i1=0; j1=1; }
    const x1 = x0 - i1 + G2; const y1 = y0 - j1 + G2; const x2 = x0 - 1 + 2*G2; const y2 = y0 - 1 + 2*G2;
    const ii = i & 255; const jj = j & 255;
    const gi0 = grad3[perm[ii+perm[jj]] % 8];
    const gi1 = grad3[perm[ii+i1+perm[jj+j1]] % 8];
    const gi2 = grad3[perm[ii+1+perm[jj+1]] % 8];
    let t0 = 0.5 - x0*x0 - y0*y0; if(t0<0) n0 = 0; else { t0 *= t0; n0 = t0 * t0 * dot(gi0, x0, y0); }
    let t1 = 0.5 - x1*x1 - y1*y1; if(t1<0) n1 = 0; else { t1 *= t1; n1 = t1 * t1 * dot(gi1, x1, y1); }
    let t2 = 0.5 - x2*x2 - y2*y2; if(t2<0) n2 = 0; else { t2 *= t2; n2 = t2 * t2 * dot(gi2, x2, y2); }
    return 70 * (n0 + n1 + n2); // -1..1
  }

  // Boot
  function boot(){
    resize();
    updateTheme();
    activePalette = choosePalette(config.palette);
    makeParticles(config.count);
    requestAnimationFrame(frame);
  }
  boot();
})();
</script>
</body>
</html>