<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Prank Driver — GH Pages</title>
  <style>
    :root{--accent:#ff4d6d}
    html,body{height:100%;margin:0;background:#0b0b0e;color:#eaf;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{display:flex;align-items:center;justify-content:center;height:100%}
    .stage{width:96vw;max-width:1200px;height:72vh;min-height:380px;padding:14px;border-radius:14px;
      background:linear-gradient(180deg,#08162a,#0b0f16);box-shadow:0 12px 40px rgba(0,0,0,.6);display:flex;gap:14px}
    .left{flex:1;position:relative;overflow:hidden;border-radius:10px;background:
      radial-gradient(1000px 420px at 50% 100%, rgba(255,255,255,.05), rgba(0,0,0,0))}
    #face{position:absolute;user-select:none;pointer-events:none;filter:drop-shadow(0 10px 20px rgba(0,0,0,.6));
      width:min(28vw,320px);height:auto}

    .controls{width:380px;max-width:40%;background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.015));
      border-radius:10px;padding:14px;display:flex;flex-direction:column;gap:12px}
    .controls h2{margin:0;font-size:18px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    label{font-size:13px;color:#cfe}
    input[type=range]{width:100%}
    button{background:var(--accent);border:0;padding:8px 12px;color:#081018;border-radius:8px;font-weight:700;cursor:pointer}
    .muted{background:#334;color:#cfe}
    .small{font-size:13px;padding:6px 8px;border-radius:8px;background:#072430;color:#bfe;border:0}
    .hint{font-size:12px;color:#9ee;margin:0}
    footer{font-size:12px;color:#7da;opacity:.9}
    @media (max-width:860px){.stage{flex-direction:column;height:86vh}.controls{width:100%;max-width:none}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="left" id="left">
        <img id="face" src="./1.png" alt="friend">
      </div>

      <div class="controls">
        <h2>Prank Controls</h2>

        <div class="row">
          <button id="playBtn">Play</button>
          <button id="driveBtn" class="muted">Start Driving</button>
          <button id="stopBtn" class="small">Stop</button>
        </div>

        <div>
          <label>Bass boost</label>
          <div class="row"><input id="bass" type="range" min="0" max="30" value="20" /> <span id="bassVal">20 dB</span></div>
        </div>

        <div>
          <label>Distortion</label>
          <div class="row"><input id="dist" type="range" min="0" max="100" value="35" /> <span id="distVal">35</span></div>
        </div>

        <div>
          <label>Master volume</label>
          <div class="row"><input id="master" type="range" min="0" max="1" step="0.01" value="0.9" /> <span id="masterVal">0.90</span></div>
        </div>

        <div><label><input id="megaBass" type="checkbox" checked/> Mega bass (clipping / heavy)</label></div>

        <p class="hint">Put this beside <code>1.png</code> and <code>1.mp3</code>. Click <b>Play</b> → <b>Start Driving</b>. If direct audio fails, it falls back automatically.</p>
        <footer>Harmless pranks only.</footer>
      </div>
    </div>
  </div>

  <!-- Fast-path audio element (works on GH Pages). Falls back to WebAudio decode if needed. -->
  <audio id="audioEl" preload="auto">
    <source src="./1.mp3" type="audio/mpeg">
  </audio>

  <script>
    // ---------- Elements
    const face = document.getElementById('face');
    const left = document.getElementById('left');
    const playBtn = document.getElementById('playBtn');
    const stopBtn = document.getElementById('stopBtn');
    const driveBtn = document.getElementById('driveBtn');
    const audioEl = document.getElementById('audioEl');

    const bass = document.getElementById('bass'), bassVal = document.getElementById('bassVal');
    const dist = document.getElementById('dist'), distVal = document.getElementById('distVal');
    const master = document.getElementById('master'), masterVal = document.getElementById('masterVal');
    const megaBass = document.getElementById('megaBass');

    // ---------- FX graph (shared by both paths)
    let audioCtx, masterGain, lowShelf, shaper;
    function ensureAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      lowShelf = audioCtx.createBiquadFilter(); lowShelf.type='lowshelf'; lowShelf.frequency.value=200;
      shaper = audioCtx.createWaveShaper(); shaper.oversample='4x';
      masterGain = audioCtx.createGain();

      // we’ll connect sources into lowShelf as entry point
      lowShelf.connect(shaper); shaper.connect(masterGain); masterGain.connect(audioCtx.destination);
      applyFX();
    }
    function makeDistortionCurve(amount){
      const k = amount, n = 44100, c = new Float32Array(n), deg = Math.PI/180;
      for(let i=0;i<n;i++){ const x=(i*2)/n - 1; c[i]=(3+k)*x*20*deg/(Math.PI+k*Math.abs(x)); }
      return c;
    }
    function applyFX(){
      const boost = Number(bass.value) * (megaBass.checked ? 2.5 : 1);
      if(lowShelf) lowShelf.gain.value = boost;
      if(shaper) shaper.curve = makeDistortionCurve(Number(dist.value));
      if(masterGain) masterGain.gain.value = Number(master.value);
      bassVal.textContent = bass.value + ' dB';
      distVal.textContent = dist.value;
      masterVal.textContent = Number(master.value).toFixed(2);
    }
    [bass, dist, master].forEach(el=>el.addEventListener('input', applyFX));
    megaBass.addEventListener('change', applyFX);

    // ---------- Playback paths
    let sourceNodeEl = null;              // MediaElementSource for the fast path
    let bufferSourceNode = null;          // BufferSource for the fallback
    let decodedBuffer = null;

    function stopAll(){
      try{ audioEl.pause(); audioEl.currentTime = 0; }catch{}
      if(sourceNodeEl){ try{ sourceNodeEl.disconnect(); }catch{} sourceNodeEl = null; }
      if(bufferSourceNode){ try{ bufferSourceNode.stop(0); bufferSourceNode.disconnect(); }catch{} bufferSourceNode = null; }
    }

    async function playFastPath(){
      // Use <audio> element -> MediaElementSource -> FX
      ensureAudio();
      if(!sourceNodeEl){
        sourceNodeEl = audioCtx.createMediaElementSource(audioEl);
        sourceNodeEl.connect(lowShelf);
      }
      if(audioCtx.state === 'suspended') await audioCtx.resume();
      audioEl.loop = true;
      await audioEl.play(); // will throw if unsupported
    }

    async function playFallback(){
      // Fetch + decode 1.mp3 from the same hosted path, feed BufferSource -> FX
      ensureAudio();
      if(audioCtx.state === 'suspended') await audioCtx.resume();
      if(!decodedBuffer){
        const res = await fetch('./1.mp3', {cache:'reload'});
        if(!res.ok) throw new Error('Fetch failed: ' + res.status);
        const data = await res.arrayBuffer();
        decodedBuffer = await new Promise((resolve, reject)=>audioCtx.decodeAudioData(data, resolve, reject));
      }
      bufferSourceNode = audioCtx.createBufferSource();
      bufferSourceNode.buffer = decodedBuffer;
      bufferSourceNode.loop = true;
      bufferSourceNode.connect(lowShelf);
      bufferSourceNode.start(0);
    }

    playBtn.addEventListener('click', async ()=>{
      // Auto-boost before play
      bass.value = 20; dist.value = 35; megaBass.checked = true; applyFX();

      stopAll();
      try{
        // Try the simple path first (works fine on GH Pages with correct MIME)
        await playFastPath();
      }catch(e){
        // If the element refused (codec sniff/MIME edge cases), use WebAudio decode fallback
        try{
          await playFallback();
        }catch(err){
          alert('Could not play 1.mp3 from the site.\n' + err.message);
        }
      }
    });

    stopBtn.addEventListener('click', stopAll);

    // ---------- Bouncing movement (stays on-screen)
    let driving=false, rafId=null;
    let x=40, y=40, vx=180, vy=120; // px/s
    let lastT=null;
    function clampToBounds(){
      const box = left.getBoundingClientRect();
      const fw = face.offsetWidth, fh = face.offsetHeight;
      x = Math.min(Math.max(10, x), Math.max(10, box.width - fw - 10));
      y = Math.min(Math.max(10, y), Math.max(10, box.height - fh - 10));
      face.style.left = x + 'px';
      face.style.top  = y + 'px';
    }
    function animate(t){
      if(!driving){ lastT=null; return; }
      if(lastT==null) lastT=t;
      const dt = Math.min(0.05, (t - lastT)/1000);
      lastT = t;

      const box = left.getBoundingClientRect();
      const fw = face.offsetWidth, fh = face.offsetHeight;

      x += vx * dt; y += vy * dt;
      const m = 8;
      if(x <= m){ x = m; vx = Math.abs(vx); }
      if(y <= m){ y = m; vy = Math.abs(vy); }
      if(x + fw + m >= box.width){ x = box.width - fw - m; vx = -Math.abs(vx); }
      if(y + fh + m >= box.height){ y = box.height - fh - m; vy = -Math.abs(vy); }

      face.style.left = x + 'px';
      face.style.top  = y + 'px';

      rafId = requestAnimationFrame(animate);
    }
    function startDriving(){
      if(driving) return;
      driving = true; lastT = null; rafId = requestAnimationFrame(animate);
      driveBtn.textContent = 'Stop Driving'; driveBtn.classList.remove('muted'); driveBtn.style.background = '#34d';
    }
    function stopDriving(){
      driving = false; if(rafId) cancelAnimationFrame(rafId);
      driveBtn.textContent = 'Start Driving'; driveBtn.classList.add('muted'); driveBtn.style.background = '';
    }
    driveBtn.addEventListener('click', ()=> driving ? stopDriving() : startDriving());

    function initPosition(){ x = 24; y = Math.max(10, left.clientHeight * 0.35); clampToBounds(); }
    face.addEventListener('load', initPosition);
    window.addEventListener('resize', clampToBounds);
    if(face.complete) initPosition();
  </script>
</body>
</html>
